&#8251; XML: Extensible Markup Language  
- 데이터를 저장하고 전송하기 위한 마크업 언어  
- 사용자가 자신만의 태그를 정의하여 데이터를 구조화하는 데 사용할 수 있음  
- 데이터 요소를 정의하고 계층 구조로 구성하는데 사용  
- 일반 텍스트 형식으로 작성되며, 데이터를 계층 구조를 나타내기 위한 시작태그와 종료 태그 사이에 데이터를 포함시킴  
- 각 데이터 요소는 태그 이름과 속성(attribute)로 구성되며, 속성은 추가 정보를 제공하기 위해 데이터 요소에 추가된 속성  

```xml
<!-- ex) -->

<person>
  <name first="John" last="Doe"/>
  <age>30</age>
  <address>
    <street>Main Street</street>
    <city>London</city>
  </address>
</person>
```

<hr>

&#8251; Proxy

1. 보안 강화  
클라이언트와 서버 사이에 요청과 응답을 필터링하고 검사함으로써 보안을 강화
2. 익명성 제공  
클라이언트는 프록시를 통해 요청을 보내므로, 프록시는 클라이언트의 실제 IP 주소를 서버에 노출시키지 않을 수 있다. 이를 통해 클라이언트의 익명성을 제공할 수 있다.  
3. 캐싱  
프록시는 이전에 요청된 리소스의 사본을 저장하고 클라이언트의 요청에 따라 해당 사본을 반환함으로써 네트워크의 성능을 향상시킬 수 있음. 이를 통해 반복적으로 요청에 대한 서비스의 부하를 줄일 수 있음.  
4. 접근 제어  
프록시는 클라이언트의 요청에 대한 접근 권한을 제어할 수 있다. 특정 사이트나 리소스에 대한 액세스를 제한하거나, 사용 정책에 따라 요청을 차단할 수 있다.
5. 로드 밸런싱  
프록시는 여러 대의 서버 사이에 요청을 분산시켜 서버 부하를 분산시키는 로드 밸런싱 기능을 수행할 수 있음. 이를 통해 서버의 성능과 가용성 향상 가능.

<hr>

&#8251; Serializer

객체나 데이터 구조를 저장하거나 전송하기 위해 해당 객체나 데이터를 일련의 바이트 형태로 변환하는 과정. 직렬화를 통해 변환된 데이터는 나중에 역직렬화(Deserialization)하여 원래의 객체나 데이터 구조로 복원될 수 있음.  

직렬화는 다음과 같은 목적을 사용할 수 있음  

1. 데이터를 저장  
직렬화는 객체나 데이터를 파일 시스템이나 데이터베이스에 저장할 수 있는 형태로 변환. 이를 통해 데이터르 영속적으로 저장하고 나중에 읽어올 수 있음.  
2. 네트워크 전송  
직렬화는 객체나 데이터를 네트워크를 통해 전송 가능한 형태로 변환. 이를 통해 원격 시스템 간에 데이터를 주고 받을 수 있음.  
3. 메모리 공유  
직렬화를 통해 객체나 데이터를 메모리에서 다른 프로세스나 스레드로 전달할 수 있음. 이를 통해 동일한 데이터를 공유하고 상태를 유지할 수 있음.  

**어떤 환경, 언어를 쓰던지 간에 통신이 가능한 언어를 만들고 싶었고, 이를 위해 탄생한 것이 XML(text)이다. (JSON 이전의 데이터)**

<hr>

CBD -> SOA  

- CBD(Component Based Development): `컴포넌트 기반 개발`  
애플리케이션을 통째로 개발하지 않고, `의미있는 단위`로 구분하고 그 단위를 하나하나씩 부품으로 개발해 마치 레고 블록을 쌓아 올리듯 부품을 결합해 소프트웨어 제품을 완성하자는 방법론  

- SOA(Service Oriented Architecture): `서비스 지향 구조`  
개발자 입장에서의 개발이 아니라 `실제 현실의 업무를 기준으로 개발`하자는 사상

<hr>

&#8251; SDLC  

Software Development Life Cycle  

<hr>

&#8251; MSA

MicroService Architecture  

작고, 독립적으로 배포 가능한 각각의 기능을 수행하는 서비스로 구성된 프레임워크  
완전히 독립적으로 배포 가능하고, 다른 기술 스택(개발 언어, 데이터베이스 등)이 사용 가능한 단일 사업 영역에 초점을 둔다.  

<hr>  

&#8251; SRP  

Single Responsibility Principle: 단일 책임 원칙  
- 객체는 단 하나의 책임만 가져야 한다는 원칙  
- 여기서 말하는 책임은 하나의 `기능 담당`으로 보면 된다.  
- 즉, `하나의 클래스는 하나의 기능을 담당하여 하나의 책임을 수행`하는데 집중되어야 한다는 의미  

&#8251; 보안의 분류  

1. 관리적 보안  
법규, 규제(개인정보 보호법, ...)  
2. 물리적 보안  
CCTV, card ...
3. 기술적 보안  
Network, Sotware(os), DB, Application